#ifndef ACTION_BROADCAST_RELIABLE_H
#define ACTION_BROADCAST_RELIABLE_H

#include "action_base.h"
#include <vector>

#include "common/optional_parameter.h"

namespace Controllers {


template<typename DATA_TYPE, typename COMPONENT_KEY>
class IActionBroadcastReliable
{
public:
    virtual void BroadcastReliable(const DATA_TYPE &commandItem, const COMPONENT_KEY &sender, const std::vector<COMPONENT_KEY> &targets) = 0;
};



//!
//! \brief Sets up an action for a reliable broadcast of data
//!
//! This action will can send multiple packet per given DATA_TYPE.
//!
//! "Reliable" means action will be redone until a message of type MESSAGE_ACK_ID is seen that generates a QUEUE_TYPE object equivilant to what is generated by this action.
//! This is to be executed by other actions, perhaps ActionFinish or ActionIntermediateReceive
//!
//! This action will send a single message out initially. Then listen for the resulting {MESSAGE_ACK_ID, QUEUE_TYPE} pair from each of the targets sent to.
//! If after the timeout, as established by the queue, all targets haven't confirmed then this action will resend the message to those that remain.
//!
//! User of this action must impliment Construct_ReliableBroadcast_Vector method that defines how to translate given data (DATA_TYPE) from a given sender (COMPONENT_KEY) to a target (COMPONENT_KEY)
//!  into relevant outgoing message vector (std::vector<MSG_TYPE>) and queue (QUEUE_TYPE)
//!
//! \template MESSAGE_TYPE Underlaying communication datastructure that all communication is done through
//! \template COMPONENT_KEY Type that identifies components on the controller network
//! \template CONTROLLER_TYPE Type of controller being used by this action, will be used to queue transmissions.
//! \template QUEUE_TYPE Type of object that will establish uniqueness in the queue, allowing the same action to handle multiple transmissions
//! \template DATA_TYPE Data type of data that will be given to the action to transmit out.
//! \template MSG_TYPE Datatype that represents the desired message on the comm paradigm.
//! \template MESSAGE_ACK_ID intenger ID that identifies the message that is to stop transmission
//!
template<typename MESSAGE_TYPE, typename COMPONENT_KEY, typename CONTROLLER_TYPE, typename DATA_TYPE, typename QUEUE_TYPE, typename MSG_TYPE, const int MESSAGE_ACK_ID>
class ActionBroadcastReliable_MultiPacket :
        public ActionBase<CONTROLLER_TYPE>,
        public BaseEncode<COMPONENT_KEY, MESSAGE_TYPE, MSG_TYPE>,
        public IActionBroadcastReliable<DATA_TYPE, COMPONENT_KEY>
{

    typedef ActionBase<CONTROLLER_TYPE> BASE;

public:

    ActionBroadcastReliable_MultiPacket(CONTROLLER_TYPE *controller,
               const std::function<void(COMPONENT_KEY, uint8_t, MESSAGE_TYPE*, const MSG_TYPE*)> &encode_chan) :
        ActionBase<CONTROLLER_TYPE>(controller),
        BaseEncode<COMPONENT_KEY, MESSAGE_TYPE, MSG_TYPE>(encode_chan)
    {

    }


    virtual void Construct_ReliableBroadcast_Vector(const DATA_TYPE &data, const COMPONENT_KEY &sender, std::vector<MSG_TYPE> &msg, QUEUE_TYPE &queue) = 0;

    //!
    //! \brief Conduct a reliable broadcast to given set of targets.
    //!
    //! A reliable broadcast will send a single transmission out to every module, and will resend to any modules that it was expecting to hear back from and never did.
    //!
    //! \param commandItem Data to send to targets
    //! \param sender Module sending data
    //! \param targets Set of targets to receive data
    //!
    virtual void BroadcastReliable(const DATA_TYPE &commandItem, const COMPONENT_KEY &sender, const std::vector<COMPONENT_KEY> &targets)
    {
        std::vector<MSG_TYPE> vec;
        QUEUE_TYPE queue;
        Construct_ReliableBroadcast_Vector(commandItem, sender, vec, queue);

        printf("--------------------------------------------------------------------\n");
        printf("%d\n", (int)targets.size());

        BASE::m_Controller-> template QueueReliableBroadcast<QUEUE_TYPE>(queue, MESSAGE_ACK_ID, targets, [this, vec, sender, targets](const std::vector<COMPONENT_KEY> &unheard){

            // if the number of components we have heard from is same as the initial targets, then do a single broadcast
            // Otherwise issue a single directed send
            if(unheard.size() == targets.size())
            {
                printf("---------------Sending Broadcast\n");
                for(auto it = vec.cbegin() ; it != vec.cend() ; ++it)
                {
                    BASE::m_Controller-> template EncodeMessage(BaseEncode<COMPONENT_KEY, MESSAGE_TYPE, MSG_TYPE>::m_EncodeChanFunc, *it, sender);
                }
            }
            else
            {
                for(auto msgit = vec.cbegin() ; msgit != vec.cend() ; ++msgit)
                {
                    for(auto unheardit = unheard.cbegin() ; unheardit != unheard.cend() ; ++unheardit)
                    {
                        printf("----------------Sending targeted message\n");
                        BASE::m_Controller-> template EncodeMessage(BaseEncode<COMPONENT_KEY, MESSAGE_TYPE, MSG_TYPE>::m_EncodeChanFunc, *msgit, sender, *unheardit);
                    }
                }
            }
        });

    }
};


//!
//! \brief Sets up an action for a reliable broadcast of data
//!
//! This action will send a single packet per DATA_TYPE given.
//!
//! "Reliable" means action will be redone until a message of type MESSAGE_ACK_ID is seen that generates a QUEUE_TYPE object equivilant to what is generated by this action.
//! This is to be executed by other actions, perhaps ActionFinish or ActionIntermediateReceive
//!
//! This action will send a single message out initially. Then listen for the resulting {MESSAGE_ACK_ID, QUEUE_TYPE} pair from each of the targets sent to.
//! If after the timeout, as established by the queue, all targets haven't confirmed then this action will resend the message to those that remain.
//!
//! User of this action must impliment Construct_ReliableBroadcast method that defines how to translate given data (DATA_TYPE) from a given sender (COMPONENT_KEY) to a target (COMPONENT_KEY)
//!  into relevant outgoing message (MSG_TYPE) and queue (QUEUE_TYPE)
//!
//! \template MESSAGE_TYPE Underlaying communication datastructure that all communication is done through
//! \template COMPONENT_KEY Type that identifies components on the controller network
//! \template CONTROLLER_TYPE Type of controller being used by this action, will be used to queue transmissions.
//! \template QUEUE_TYPE Type of object that will establish uniqueness in the queue, allowing the same action to handle multiple transmissions
//! \template DATA_TYPE Data type of data that will be given to the action to transmit out.
//! \template MSG_TYPE Datatype that represents the desired message on the comm paradigm.
//! \template MESSAGE_ACK_ID intenger ID that identifies the message that is to stop transmission
//!
template<typename MESSAGE_TYPE, typename COMPONENT_KEY, typename CONTROLLER_TYPE, typename DATA_TYPE, typename QUEUE_TYPE, typename MSG_TYPE, const int MESSAGE_ACK_ID>
class ActionBroadcastReliable :
        public ActionBroadcastReliable_MultiPacket<MESSAGE_TYPE, COMPONENT_KEY, CONTROLLER_TYPE, DATA_TYPE, QUEUE_TYPE, MSG_TYPE, MESSAGE_ACK_ID>
{
public:
    ActionBroadcastReliable(CONTROLLER_TYPE *controller,
               const std::function<void(COMPONENT_KEY, uint8_t, MESSAGE_TYPE*, const MSG_TYPE*)> &encode_chan) :
        ActionBroadcastReliable_MultiPacket<MESSAGE_TYPE, COMPONENT_KEY, CONTROLLER_TYPE, DATA_TYPE, QUEUE_TYPE, MSG_TYPE, MESSAGE_ACK_ID>(controller, encode_chan)
    {

    }

    virtual void Construct_ReliableBroadcast(const DATA_TYPE &data, const COMPONENT_KEY &sender, MSG_TYPE &msg, QUEUE_TYPE &queue) = 0;

    virtual void Construct_ReliableBroadcast_Vector(const DATA_TYPE &data, const COMPONENT_KEY &sender, std::vector<MSG_TYPE> &vec, QUEUE_TYPE &queue)
    {
        MSG_TYPE msg;
        Construct_ReliableBroadcast(data, sender, msg, queue);
        vec = {msg};

        return;
    }
};

}

#endif // ACTION_BROADCAST_RELIABLE_H
