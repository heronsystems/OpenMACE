#ifndef ACTION_UNSOLICITED_RECEIVE_RESPOND_H
#define ACTION_UNSOLICITED_RECEIVE_RESPOND_H

#include "action_base.h"

#include "../base_data_item.h"

namespace Controllers {

//!
//! \brief Action to receive an message type and generates a response to the sender
//!
//! Use of this method requires the caller to set a lambda in setLambda_DataReceived with approriate FINAL_TYPE object.
//! The lambda set will be called when data is received by this method.
//!
//! \template MESSAGE_TYPE Underlaying generic message type that all communication is done through
//! \template COMPONENT_KEY Type that identifies actors on the network
//! \template CONTROLLER_TYPE Type of controller being used by this action, will be used to queue transmissions.
//! \template FINAL_KEY type of object that will key the object being sent up.
//! \template FINAL_TYPE Type of object that will contain data that is to be sent up.
//! \template MSG_TYPE Type of communications messsage that is to be transmitted out
//! \template ACK_TYPE Data type to respond to sender with.
//! \template MESSAGE_REQUEST_ID Integer code for message that is to kick off this action
//!
template<typename MESSAGE_TYPE, typename COMPONENT_KEY, typename CONTROLLER_TYPE, typename FINAL_KEY, typename FINAL_TYPE, typename MSG_TYPE, typename ACK_TYPE, const int MESSAGE_REQUEST_ID>
class ActionUnsolicitedReceiveRespond :
        public ActionBase<CONTROLLER_TYPE>,
        public BaseEncode<COMPONENT_KEY, MESSAGE_TYPE, ACK_TYPE>,
        public BaseDecode<COMPONENT_KEY, MESSAGE_TYPE, MSG_TYPE>
{

    typedef ActionBase<CONTROLLER_TYPE> BASE;

protected:

    //!
    //! \brief Method to be implimented that defines how to translate between received message and outgoing data
    //! \param msg Received message
    //! \param sender Module sending message
    //! \param data Data to be generated by message
    //! \return True if message is to be consumed, false if ignored (and possibly consumed by another action)
    //!
    virtual bool Construct_FinalObjectAndResponse(const MSG_TYPE &msg, const COMPONENT_KEY &sender, ACK_TYPE &, COMPONENT_KEY &componentResponding, FINAL_KEY &key, FINAL_TYPE &data)= 0;

public:

    ActionUnsolicitedReceiveRespond(CONTROLLER_TYPE *controller,
                           const std::function<void(const MESSAGE_TYPE*, MSG_TYPE*)> &decode,
                            const std::function<void(COMPONENT_KEY, uint8_t, MESSAGE_TYPE*, const ACK_TYPE*)> &encode_ack_chan) :
        ActionBase<CONTROLLER_TYPE>(controller),
        BaseEncode<COMPONENT_KEY, MESSAGE_TYPE, ACK_TYPE>(encode_ack_chan),
        BaseDecode<COMPONENT_KEY, MESSAGE_TYPE, MSG_TYPE>(decode)
    {

        BASE::m_Controller-> template AddTriggeredLogic<MESSAGE_REQUEST_ID, MSG_TYPE>( BaseDecode<COMPONENT_KEY, MESSAGE_TYPE, MSG_TYPE>::m_DecodeFunc,
                [this](const MSG_TYPE  &msg, const COMPONENT_KEY &sender){

                    COMPONENT_KEY target = sender;
                    COMPONENT_KEY componentResponding;

                    FINAL_KEY finalKey;
                    FINAL_TYPE finalObj;

                    ACK_TYPE ack;
//                    bool valid = this-> template Construct_FinalObjectAndResponse(msg, sender, ack, componentResponding, finalKey, finalObj);
                    bool valid = this->Construct_FinalObjectAndResponse(msg, sender, ack, componentResponding, finalKey, finalObj);

                    if(valid == true)
                    {
                        ((Controllers::DataItem<FINAL_KEY, FINAL_TYPE>*)BASE::m_Controller)->onDataReceived(finalKey, finalObj);
                        BASE::m_Controller->template EncodeMessage(BaseEncode<COMPONENT_KEY, MESSAGE_TYPE, ACK_TYPE>::m_EncodeChanFunc, ack, componentResponding, target);
                    }

                    return valid;
                }
        );
    }

protected:
};

}

#endif // ACTION_UNSOLICITED_RECEIVE_RESPOND_H
