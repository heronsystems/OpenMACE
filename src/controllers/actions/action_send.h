#ifndef ACTION_SEND_H
#define ACTION_SEND_H

#include "action_base.h"

#include "common/optional_parameter.h"
#include "common/object_int_tuple.h"

#include <vector>


namespace Controllers {

template<typename DATA_TYPE, typename COMPONENT_KEY>
class IActionSend
{
public:
    virtual void Send(const DATA_TYPE &commandItem, const COMPONENT_KEY &sender, const COMPONENT_KEY &target) = 0;
};


//!
//! \brief Sets up an action for a reliable send of data.
//!
//! "Reliable" means action will be redone until a message of type MESSAGE_ACK_ID is seen that generates a QUEUE_TYPE object equivilant to what is generated by this action.
//! This is to be executed by other actions, perhaps ActionFinish or ActionIntermediateReceive
//!
//! User of this action must impliment Construct_Send method that defines how to translate given data (DATA_TYPE) from a given sender (COMPONENT_KEY) to a target (COMPONENT_KEY)
//!  into relevant data (MSG_TYPE) and queue (QUEUE_TYPE)
//!
//! \template MESSAGE_TYPE Underlaying communication datastructure that all communication is done through
//! \template COMPONENT_KEY Type that identifies components on the controller network
//! \template CONTROLLER_TYPE Type of controller being used by this action, will be used to queue transmissions.
//! \template QUEUE_TYPE Type of object that will establish uniqueness in the queue, allowing the same action to handle multiple transmissions
//! \template DATA_TYPE Data type of data that will be given to the action to transmit out.
//! \template MSG_TYPE Datatype that represents the desired message on the comm paradigm.
//! \template MESSAGE_ACK_ID intenger ID that identifies the message that is to stop transmission
//!
template<typename MESSAGE_TYPE, typename COMPONENT_KEY, typename CONTROLLER_TYPE, typename QUEUE_TYPE, typename DATA_TYPE, typename MSG_TYPE, const int MESSAGE_ACK_ID>
class ActionSend :
        public ActionBase<CONTROLLER_TYPE>,
        public BaseEncode<COMPONENT_KEY, MESSAGE_TYPE, MSG_TYPE>,
        public IActionSend<DATA_TYPE, COMPONENT_KEY>
{

    typedef ActionBase<CONTROLLER_TYPE> BASE;
protected:

    //!
    //! \brief Method that is to be implimented for this action that translates a data of type DATA_TYPE and generate corrisponding message of type MSG_TYPE.
    //! This method also realizes the queue object to identify the transmission
    //!
    //! \param data Incomming data to translate, given in the Send function
    //! \param sender Component emitting this action, given in the Send function
    //! \param target Component targeted by action
    //! \param msg Communications message to send to comms interface
    //! \param queue Queue object to identifiy this tranmissions when ack is returned
    //! \return True is to procede with transmission
    //!
    virtual bool Construct_Send(const DATA_TYPE &data, const COMPONENT_KEY &sender, const COMPONENT_KEY &target, MSG_TYPE &msg, QUEUE_TYPE &queue) = 0;

public:

    ActionSend(CONTROLLER_TYPE *controller,
               const std::function<void(COMPONENT_KEY, uint8_t, MESSAGE_TYPE*, const MSG_TYPE*)> &encode_chan) :
        ActionBase<CONTROLLER_TYPE>(controller),
        BaseEncode<COMPONENT_KEY, MESSAGE_TYPE, MSG_TYPE>(encode_chan)
    {

    }


    //!
    //! \brief Send data to a given target
    //! \param data Data to send
    //! \param sender Module sending data
    //! \param target Module that is to receive the data
    //!
    void Send(const DATA_TYPE &data, const COMPONENT_KEY &sender, const COMPONENT_KEY &target)
    {
        MSG_TYPE cmd;
        QUEUE_TYPE queueObj;
        if(Construct_Send(data, sender, target, cmd, queueObj) == false)
        {
            return;
        }


        BASE::m_Controller-> template QueueTransmission<QUEUE_TYPE>(queueObj, MESSAGE_ACK_ID, target, [this, cmd, sender](const std::vector<COMPONENT_KEY> &targets){

            if(targets.size() != 1)
            {
                throw std::runtime_error("Queued transmission with one target, but received multiple to send out");
            }

            BASE::m_Controller-> template EncodeMessage(BaseEncode<COMPONENT_KEY, MESSAGE_TYPE, MSG_TYPE>::m_EncodeChanFunc, cmd, sender, targets.at(0));
        });

    }
};


//!
//! \brief Sets up an action for a reliable send of data.
//!
//! //! DIFFERENCE BETWEEN ACTIONSEND:
//! This class is slightly different than ActionSend.
//! It is capable to producing a vector of messages at one time.
//! This is to be used when one DATA_TYPE object generates multiple packets that are all to be sent.
//! For example in boundary upload a single BoundaryCharacterstic object generates multiple mace_new_boundary_object_t, one per object
//! This action is to be used to use one queue entry for each of those transmissions
//!
//! "Reliable" means action will be redone until a message of type MESSAGE_ACK_ID is seen that generates a QUEUE_TYPE object equivilant to what is generated by this action.
//! This is to be executed by other actions, perhaps ActionFinish or ActionIntermediateReceive
//!
//! User of this action must impliment Construct_Send method that defines how to translate given data (DATA_TYPE) from a given sender (COMPONENT_KEY) to a target (COMPONENT_KEY)
//!  into relevant data (MSG_TYPE) and queue (QUEUE_TYPE)
//!
//! \template MESSAGE_TYPE Underlaying communication datastructure that all communication is done through
//! \template COMPONENT_KEY Type that identifies components on the controller network
//! \template CONTROLLER_TYPE Type of controller being used by this action, will be used to queue transmissions.
//! \template QUEUE_TYPE Type of object that will establish uniqueness in the queue, allowing the same action to handle multiple transmissions
//! \template DATA_TYPE Data type of data that will be given to the action to transmit out.
//! \template MSG_TYPE Datatype that represents the desired message on the comm paradigm.
//! \template MESSAGE_ACK_ID intenger ID that identifies the message that is to stop transmission
//!
template<typename MESSAGE_TYPE, typename COMPONENT_KEY, typename CONTROLLER_TYPE, typename QUEUE_TYPE, typename DATA_TYPE, typename MSG_TYPE, const int MESSAGE_ACK_ID>
class ActionSend_Vector :
        public ActionBase<CONTROLLER_TYPE>,
        public BaseEncode<COMPONENT_KEY, MESSAGE_TYPE, MSG_TYPE>,
        public IActionSend<DATA_TYPE, COMPONENT_KEY>
{
    typedef ActionBase<CONTROLLER_TYPE> BASE;

protected:

    //!
    //! \brief Method that is to be implimented for this action that translates a data of type DATA_TYPE and generate corrisponding message of type MSG_TYPE.
    //! This method also realizes the queue object to identify the transmission
    //!
    //! \param data Incomming data to translate, given in the Send function
    //! \param sender Module emitting this action, given in the Send function
    //! \param target Module targeted by action
    //! \param msg Communications message to send to comms interface
    //! \param queue Queue object to identifiy this tranmissions when ack is returned
    //! \return True is to procede with transmission
    //!
    virtual bool Construct_Send_Vector(const DATA_TYPE &data, const COMPONENT_KEY &sender, const COMPONENT_KEY &target, std::vector<MSG_TYPE> &msg, QUEUE_TYPE &queue) = 0;

public:

    ActionSend_Vector(CONTROLLER_TYPE *controller,
               const std::function<void(COMPONENT_KEY, uint8_t, MESSAGE_TYPE*, const MSG_TYPE*)> &encode_chan) :
        ActionBase<CONTROLLER_TYPE>(controller),
        BaseEncode<COMPONENT_KEY, MESSAGE_TYPE, MSG_TYPE>(encode_chan)
    {

    }


    //!
    //! \brief Send data to a given target
    //! \param data Data to send
    //! \param sender Module sending data
    //! \param target Module that is to receive the data
    //!
    void Send(const DATA_TYPE &data, const COMPONENT_KEY &sender, const COMPONENT_KEY &target)
    {
        std::vector<MSG_TYPE> vec;
        QUEUE_TYPE queueObj;
        if(Construct_Send_Vector(data, sender, target, vec, queueObj) == false)
        {
            return;
        }

        BASE::m_Controller-> template QueueTransmission<QUEUE_TYPE>(queueObj, MESSAGE_ACK_ID, target, [this, vec, sender](const std::vector<COMPONENT_KEY> &targets){

            if(targets.size() != 1)
            {
                throw std::runtime_error("Queued transmission with one target, but received multiple to send out");
            }

            for(auto it = vec.cbegin() ; it != vec.cend() ; ++it)
            {
                MSG_TYPE msg = *it;
                BASE::m_Controller-> template EncodeMessage(BaseEncode<COMPONENT_KEY, MESSAGE_TYPE, MSG_TYPE>::m_EncodeChanFunc, msg, sender, targets.at(0));
            }

        });
    }
};

}

#endif // ACTION_SEND_H
